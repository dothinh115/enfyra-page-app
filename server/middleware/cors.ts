import { defineEventHandler } from 'h3'
import { useRuntimeConfig } from '#imports'

// Rate limiting storage
const rateLimitMap = new Map<string, { count: number; resetTime: number }>()
const RATE_LIMIT_WINDOW = 60000 // 1 minute
const RATE_LIMIT_MAX_REQUESTS = 30 // Max requests per minute per IP

export default defineEventHandler(async (event) => {
  // Ch·ªâ √°p d·ª•ng cho API routes
  if (!event.node.req.url?.startsWith('/api/') && !event.node.req.url?.startsWith('/enfyra/api/')) {
    return
  }

  // L·∫•y th√¥ng tin chi ti·∫øt v·ªÅ request
  const origin = event.node.req.headers.origin
  const referer = event.node.req.headers.referer
  const userAgent = event.node.req.headers['user-agent']
  const xForwardedFor = event.node.req.headers['x-forwarded-for']
  const xRealIp = event.node.req.headers['x-real-ip']
  const host = event.node.req.headers.host
  
  // L·∫•y IP th·∫≠t t·ª´ request
  const xForwardedForStr = Array.isArray(xForwardedFor) ? xForwardedFor[0] : xForwardedFor
  const clientIp = xRealIp || xForwardedForStr?.split(',')[0]?.trim() || event.node.req.socket?.remoteAddress || 'unknown'
  
  // Rate limiting check
  const now = Date.now()
  const rateLimitKey = `${clientIp}:${origin || 'no-origin'}`
  const rateLimitData = rateLimitMap.get(rateLimitKey)
  
  if (rateLimitData) {
    if (now < rateLimitData.resetTime) {
      // Trong window time
      if (rateLimitData.count >= RATE_LIMIT_MAX_REQUESTS) {
        console.warn('üö´ RATE LIMIT EXCEEDED:', {
          ip: clientIp,
          origin,
          count: rateLimitData.count,
          resetTime: new Date(rateLimitData.resetTime).toISOString()
        })
        
        event.node.res.statusCode = 429
        event.node.res.setHeader('Content-Type', 'application/json')
        event.node.res.setHeader('Retry-After', Math.ceil((rateLimitData.resetTime - now) / 1000))
        event.node.res.end(JSON.stringify({
          error: 'Too Many Requests',
          message: 'Rate limit exceeded. Please try again later.',
          retryAfter: Math.ceil((rateLimitData.resetTime - now) / 1000)
        }))
        return
      }
      rateLimitData.count++
    } else {
      // Reset window
      rateLimitMap.set(rateLimitKey, { count: 1, resetTime: now + RATE_LIMIT_WINDOW })
    }
  } else {
    // First request
    rateLimitMap.set(rateLimitKey, { count: 1, resetTime: now + RATE_LIMIT_WINDOW })
  }
  
  // Cleanup old entries (prevent memory leak)
  if (Math.random() < 0.01) { // 1% chance to cleanup
    for (const [key, data] of rateLimitMap.entries()) {
      if (now > data.resetTime) {
        rateLimitMap.delete(key)
      }
    }
  }
  
  // Ch·ªâ cho ph√©p domain hi·ªán t·∫°i
  const config = useRuntimeConfig()
  const currentDomain = config.public.baseUrl
  
  // Log t·∫•t c·∫£ th√¥ng tin request ƒë·ªÉ debug
  console.log('üîç CORS DEBUG:', {
    clientIp,
    origin,
    referer,
    host,
    userAgent: userAgent?.substring(0, 100),
    xForwardedFor,
    xRealIp,
    url: event.node.req.url,
    method: event.node.req.method,
    allowedDomain: currentDomain,
    rateLimitCount: rateLimitData?.count || 1
  })
  
  // Ki·ªÉm tra CORS nghi√™m ng·∫∑t
  let isAllowed = false
  let reason = ''

  // Ki·ªÉm tra origin
  if (origin) {
    if (origin === currentDomain) {
      isAllowed = true
      reason = 'Valid origin'
    } else {
      isAllowed = false
      reason = `Invalid origin: ${origin} !== ${currentDomain}`
    }
  }
  // Ki·ªÉm tra referer n·∫øu kh√¥ng c√≥ origin
  else if (referer) {
    if (referer.startsWith(currentDomain)) {
      isAllowed = true
      reason = 'Valid referer'
    } else {
      isAllowed = false
      reason = `Invalid referer: ${referer}`
    }
  }
  // N·∫øu kh√¥ng c√≥ c·∫£ origin v√† referer, c√≥ th·ªÉ l√† request n·ªôi b·ªô
  else {
    // Ch·ªâ cho ph√©p n·∫øu kh√¥ng c√≥ origin/referer v√† l√† request n·ªôi b·ªô
    if (!userAgent || userAgent.includes('curl') || userAgent.includes('Postman')) {
      isAllowed = false
      reason = 'No origin/referer but suspicious user agent'
    } else {
      isAllowed = true
      reason = 'Internal request (no origin/referer)'
    }
  }

  // N·∫øu request kh√¥ng ƒë∆∞·ª£c ph√©p, ch·∫∑n ngay l·∫≠p t·ª©c
  if (!isAllowed) {
    console.warn('üö´ CORS BLOCKED:', reason, {
      origin,
      referer,
      host,
      userAgent,
      url: event.node.req.url,
      method: event.node.req.method
    })
    
    // Tr·∫£ v·ªÅ l·ªói 403 Forbidden
    event.node.res.statusCode = 403
    event.node.res.setHeader('Content-Type', 'application/json')
    event.node.res.end(JSON.stringify({
      error: 'Forbidden',
      message: 'Access denied: Request not allowed from this domain',
      reason
    }))
    return
  }

  // Set CORS headers cho request ƒë∆∞·ª£c ph√©p
  event.node.res.setHeader('Access-Control-Allow-Origin', currentDomain)
  event.node.res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, PATCH, OPTIONS')
  event.node.res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With')
  event.node.res.setHeader('Access-Control-Allow-Credentials', 'true')

  // X·ª≠ l√Ω preflight request
  if (event.node.req.method === 'OPTIONS') {
    event.node.res.statusCode = 200
    event.node.res.end()
    return
  }

  console.log('‚úÖ CORS ALLOWED:', reason, {
    clientIp,
    origin: origin || 'none',
    referer: referer || 'none',
    host: host || 'none',
    rateLimitCount: rateLimitData?.count || 1
  })
})
